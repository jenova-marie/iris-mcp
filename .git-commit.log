===== Git Commit Session [2025-10-17 16:42:30] =====
Session ID: 1729210950
Current Branch: main
Total Commits Created: 6

--- Commits Created ---
1. 7563139 - refactor(transport): extract command building and improve debug info capture
2. 49b2a46 - feat(session): add launch command and config snapshot tracking
3. c4274c5 - feat(dashboard): add real-time permission approval via WebSocket
4. 57ee20f - feat(dashboard): add log viewer with streaming and level filtering
5. 58f17ae - docs: add dashboard CLAUDE.md and update agents
6. a2b88ec - docs(config): document launch command debugging and update examples
7. b5b8ce8 - chore: update git-commit workflow and bump version

--- Source Changes (src/ only) ---
Files Modified: 23
Total Diff Lines: 2382

diff --git a/src/actions/reboot.ts b/src/actions/reboot.ts
index 22a7fb2..849d3b3 100644
--- a/src/actions/reboot.ts
+++ b/src/actions/reboot.ts
@@ -165,11 +165,29 @@ export async function reboot(
   );
 
   try {
-    await processPool.getOrCreateProcess(
+    const process = await processPool.getOrCreateProcess(
       toTeam,
       newSession.sessionId,
       fromTeam,
     );
+
+    // Update session with debug info (if available from transport)
+    const launchCommand = process.getLaunchCommand?.();
+    const teamConfigSnapshot = process.getTeamConfigSnapshot?.();
+
+    if (launchCommand && teamConfigSnapshot) {
+      sessionManager.updateDebugInfo(
+        newSession.sessionId,
+        launchCommand,
+        teamConfigSnapshot,
+      );
+      logger.info("Updated session debug info after reboot", {
+        sessionId: newSession.sessionId,
+        commandLength: launchCommand.length,
+        configLength: teamConfigSnapshot.length,
+      });
+    }
+
     logger.info(
       { fromTeam, toTeam, newSessionId: newSession.sessionId },
       "Team woken successfully with new session",
diff --git a/src/actions/wake.ts b/src/actions/wake.ts
index 6501074..9c9739b 100644
--- a/src/actions/wake.ts
+++ b/src/actions/wake.ts
@@ -104,6 +104,29 @@ export async function wake(
       );
       const metrics = process.getBasicMetrics();
 
+      // Update session with debug info (if available from transport)
+      const launchCommand = process.getLaunchCommand?.();
+      const teamConfigSnapshot = process.getTeamConfigSnapshot?.();
+
+      if (launchCommand && teamConfigSnapshot) {
+        sessionManager.updateDebugInfo(
+          session.sessionId,
+          launchCommand,
+          teamConfigSnapshot,
+        );
+        logger.info("Updated session debug info after wake", {
+          sessionId: session.sessionId,
+          commandLength: launchCommand.length,
+          configLength: teamConfigSnapshot.length,
+        });
+      } else {
+        logger.warn("Debug info not available from transport after wake", {
+          sessionId: session.sessionId,
+          hasLaunchCommand: !!launchCommand,
+          hasTeamConfig: !!teamConfigSnapshot,
+        });
+      }
+
       // Update session state to idle after spawn completes
       // This ensures the session is ready to accept messages
       sessionManager.updateProcessState(session.sessionId, "idle");
diff --git a/src/config/iris-config.ts b/src/config/iris-config.ts
index cb20be6..2aea4eb 100644
--- a/src/config/iris-config.ts
+++ b/src/config/iris-config.ts
@@ -60,7 +60,7 @@ const IrisConfigSchema = z
     grantPermission: z
       .enum(["yes", "no", "ask", "forward"])
       .optional()
-      .default("yes"), // How to handle permission requests
+      .default("ask"), // How to handle permission requests (default: ask for safety)
     // Tool allowlist/denylist
     allowedTools: z.string().optional(), // Comma-separated list of allowed MCP tools (passed to Claude CLI --allowed-tools flag)
     disallowedTools: z.string().optional(), // Comma-separated list of denied MCP tools (passed to Claude CLI --disallowed-tools flag)
diff --git a/src/dashboard/CLAUDE.md b/src/dashboard/CLAUDE.md
new file mode 100644
index 0000000..652fe41
--- /dev/null
+++ b/src/dashboard/CLAUDE.md
@@ -0,0 +1,326 @@
+# CLAUDE.md
+
+This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.
+
+# Iris Dashboard - Phase 2 Web Monitoring Interface
+
+This is the **Phase 2** web dashboard for Iris MCP, providing real-time monitoring and control of Claude process pools through a React SPA with WebSocket updates.
+
+## Project Context
+
+**Parent Project**: This is a child project within the larger `iris-mcp` system (`/Users/jenova/projects/jenova-marie/iris-mcp`).
+
+**Location**: `/Users/jenova/projects/jenova-marie/iris-mcp/src/dashboard`
+
+**Relationship to Parent**: The dashboard integrates with Phase 1's process pooling infrastructure via `DashboardStateBridge`, which provides read-only access to:
+- `ClaudeProcessPool` (runtime process status)
+- `SessionManager` (persistent session data in SQLite)
+- `TeamsConfigManager` (hot-reloadable YAML configuration)
+- `PendingPermissionsManager` (permission approval system)
+
+## Build Commands
+
+All commands run from the **parent directory** (`/Users/jenova/projects/jenova-marie/iris-mcp`):
+
+```bash
+# Build everything (server + dashboard client)
+pnpm build
+
+# Build only dashboard client
+pnpm build:client
+
+# Development mode - Vite dev server with hot reload (port 5173)
+pnpm dev:client
+
+# Development mode - Watch parent server (port 3100)
+pnpm dev
+
+# Run tests
+pnpm test
+```
+
+**Important**: The dashboard has no package.json in `src/dashboard/` - it's managed by the parent's pnpm workspace. Client dependencies are in `src/dashboard/client/package.json`.
+
+## Architecture Overview
+
+### Three-Layer Architecture
+
+1. **Express Server** (`server/index.ts`) - Serves React SPA, REST API, WebSocket
+2. **State Bridge** (`server/state-bridge.ts`) - Read-only facade over MCP internals
+3. **React Client** (`client/src/`) - SPA with TanStack Query, Socket.io, React Router
+
+### Session-Based Data Model
+
+**Critical Design**: Everything is organized around **session pairs** (`fromTeam->toTeam`), not individual teams.
+
+- **poolKey**: `"team-iris->team-alpha"` - Unique identifier for a session
+- **SessionProcessInfo**: Combines persistent session data (SQLite) with runtime process status (in-memory pool)
+- Sessions can exist without active processes (stopped state)
+- Active processes are always tied to a specific session
+
+### HTTP + HTTPS Dual Server Support
+
+The Express server supports simultaneous HTTP and HTTPS on different ports:
+
+```yaml
+dashboard:
+  http: 3100        # HTTP server (0 to disable)
+  https: 3443       # HTTPS server (0 to disable)
+  selfsigned: true  # Auto-generate self-signed cert
+  certPath: /path/to/cert.pem  # Or use custom cert
+  keyPath: /path/to/key.pem
+```
+
+- Self-signed certificates auto-generated with proper SAN for localhost/127.0.0.1
+- At least one protocol (HTTP or HTTPS) must be enabled
+- Socket.io attaches to the first available server (HTTP priority)
+
+### State Bridge (`server/state-bridge.ts`)
+
+The bridge is the **only** interface between dashboard and MCP internals. It:
+
+- **Merges two sources of truth**: SessionManager (persistent) + ProcessPool (runtime)
+- **Forwards events** via EventEmitter: `ws:process-status`, `ws:permission:request`, etc.
+- **Provides read methods**: `getActiveSessions()`, `getSessionMetrics()`, `getSessionReport()`
+- **Provides action methods**: `sleepSession()`, `rebootSession()`, `deleteSession()`, `forkSession()`
+
+**Key Methods**:
+
+- `getActiveSessions()` - Returns ALL sessions (active + stopped) with combined data
+- `getSessionMetrics(fromTeam, toTeam)` - Detailed metrics for one session
+- `getSessionReport(fromTeam, toTeam)` - Message cache with conversation history
+- `getPendingPermissions()` - Active permission requests awaiting approval
+- `resolvePermission(permissionId, approved, reason)` - Approve/deny from dashboard
+
+### WebSocket Event Flow
+
+**Server → Client Events** (auto-forwarded from bridge):
+- `init` - Initial state on connection (sessions, config, poolStatus, pendingPermissions)
+- `process-status` - Process lifecycle updates (spawned, terminated, idle, processing)
+- `cache-stream` - Real-time message cache streaming (not yet implemented)
+- `config-saved` - Configuration file saved
+- `permission:request` - New permission request from Claude
+- `permission:resolved` - Permission approved/denied
+- `permission:timeout` - Permission request timed out
+
+**Client → Server Events**:
+- `stream-cache` - Request cache streaming for a sessionId
+- `permission:response` - Approve/deny permission request
+
+### REST API Routes
+
+**Health Check**:
+- `GET /api/health` - Server health status
+
+**Configuration** (`server/routes/config.ts`):
+- `GET /api/config` - Get current teams configuration
+- `PUT /api/config` - Update configuration (hot-reload)
+
+**Processes/Sessions** (`server/routes/processes.ts`):
+- `GET /api/processes` - All sessions with pool status
+- `GET /api/processes/:fromTeam/:toTeam` - Session metrics
+- `GET /api/processes/report/:fromTeam/:toTeam` - Message cache report
+- `POST /api/processes/sleep/:fromTeam/:toTeam` - Terminate process
+- `POST /api/processes/reboot/:fromTeam/:toTeam` - Clear and restart session
+- `POST /api/processes/delete/:fromTeam/:toTeam` - Delete session permanently
+- `POST /api/processes/terminal/launch` - Fork session to new terminal (via sessionId)
+
+### Client Architecture (`client/src/`)
+
+**Tech Stack**:
+- **React 18.2** with TypeScript
+- **Vite** for development (port 5173) and production builds
+- **TanStack Query** for server state management
+- **Socket.io-client** for WebSocket connections
+- **React Router** for navigation
+- **Axios** for HTTP requests
+
+**Key Files**:
+- `App.tsx` - Router setup, QueryClient, permission modal management
+- `hooks/useWebSocket.ts` - WebSocket connection with callback refs pattern
+- `api/client.ts` - Axios instance with interceptors
+- `pages/ProcessMonitor.tsx` - Main dashboard view
+- `pages/ConfigEditor.tsx` - YAML config editor
+- `components/PermissionApprovalModal.tsx` - Permission approval UI
+
+**WebSocket Hook Pattern**:
+
+The `useWebSocket` hook uses **callback refs** to allow callback updates without reconnecting:
+
+```typescript
+const { connected, streamCache, respondToPermission } = useWebSocket(
+  onProcessStatus,  // Callback for process updates
+  onCacheStream,    // Callback for cache streaming
+  onPermissionRequest, // Callback for permission requests
+);
+```
+
+Callbacks are stored in refs and updated on each render, while the socket connection remains stable.
+
+### Permission Approval System
+
+The dashboard can approve/deny Claude Code permission requests in real-time:
+
+1. Claude requests permission → `PermissionManager` creates pending request
+2. Bridge forwards `permission:request` event → Dashboard WebSocket emits to all clients
+3. User approves/denies in `PermissionApprovalModal`
+4. Dashboard sends `permission:response` via WebSocket
+5. Bridge calls `resolvePermission()` → PermissionManager unblocks Claude
+
+**Timeout Handling**: Permissions auto-timeout after 5 minutes (configurable). Modal receives `permission:timeout` event.
+
+### Static File Serving
+
+The Express server serves the built React SPA from `dist/dashboard/public`:
+
+```typescript
+app.use(express.static(publicPath));
+app.get('*', (req, res) => {
+  // SPA fallback - all non-API routes serve index.html
+});
+```
+
+**Development**: Use `pnpm dev:client` for Vite dev server with proxy to Express backend on port 3100.
+
+**Production**: Run `pnpm build:client` then `pnpm start` - Express serves pre-built static files.
+
+### Vite Configuration (`client/vite.config.ts`)
+
+- **Output**: `../../../dist/dashboard/public` (parent's dist folder)
+- **Dev Server**: Port 5173 with proxy to `http://localhost:3100` for `/api` and `/ws`
+- **Alias**: `@/` maps to `./src` for cleaner imports
+- **Source Maps**: Enabled in production builds
+
+### Environment Variables
+
+**Client** (Vite):
+- `VITE_API_URL` - API base URL (default: `/api`)
+- `VITE_WS_URL` - WebSocket URL (default: `http://localhost:3100`)
+
+**Server** (via parent config):
+- `IRIS_HOME` - Iris configuration directory (default: `~/.iris`)
+- `DEBUG` - Enable debug logging
+
+## Development Workflow
+
+### Local Development with Hot Reload
+
+**Terminal 1** - Run parent MCP server with watch mode:
+```bash
+cd /Users/jenova/projects/jenova-marie/iris-mcp
+pnpm dev
+```
+
+**Terminal 2** - Run Vite dev server for React client:
+```bash
+cd /Users/jenova/projects/jenova-marie/iris-mcp
+pnpm dev:client
+```
+
+Open browser to `http://localhost:5173` - Vite proxies API requests to Express on port 3100.
+
+### Production Build
+
+```bash
+cd /Users/jenova/projects/jenova-marie/iris-mcp
+pnpm build         # Builds server + client
+pnpm start         # Serves production build
+```
+
+Dashboard available at `http://localhost:3100` (configured via `config.yaml`).
+
+### Debugging WebSocket Issues
+
+All WebSocket events are logged to browser console with `[WebSocket]` prefix. Check:
+
+1. Connection status in `useWebSocket` hook
+2. Event payloads in browser DevTools console
+3. Server logs (stderr) with `dashboard:server` context
+
+## Key Design Decisions
+
+### Why Session-Based, Not Team-Based?
+
+- A "team" in config.yaml is just a folder path
+- Real conversations happen between **team pairs** (e.g., iris→alpha, iris→beta)
+- Each pair has a unique session ID, message cache, and optional running process
+- Multiple sessions can use the same team config (different fromTeam)
+
+### Why DashboardStateBridge?
+
+- **Separation of concerns**: Dashboard doesn't directly import MCP action handlers
+- **Event forwarding**: Bridge converts internal pool events to WebSocket events
+- **Read-only safety**: Dashboard can't accidentally mutate pool state
+- **Testing**: Bridge can be mocked for client-side tests
+
+### Why Dual SessionManager + ProcessPool?
+
+- **SessionManager** (SQLite): Persistent data survives restarts, shows all sessions
+- **ProcessPool** (in-memory): Runtime status of currently active processes
+- **Bridge merges both**: Complete picture of what exists vs what's running
+
+### Why Callback Refs in useWebSocket?
+
+- Avoids reconnecting socket on every callback change
+- Allows parent components to update callbacks freely
+- Single socket instance per component lifecycle
+
+## Testing Strategy
+
+**Client Tests** (not yet implemented):
+- Component tests with Vitest + Testing Library
+- Mock WebSocket events via `useWebSocket` hook
+- Mock Axios requests via MSW
+
+**Server Tests** (not yet implemented):
+- Integration tests with real DashboardStateBridge
+- WebSocket event forwarding tests
+- API endpoint tests with supertest
+
+## Future Enhancements
+
+From `README.md` planned features:
+- Live message stream (cache streaming implementation pending)
+- Analytics dashboard (process pool metrics over time)
+- Team management UI (add/edit teams without editing YAML)
+- Multi-user support (authentication, user sessions)
+
+## Common Debugging Tasks
+
+**Dashboard not loading**:
+1. Check Express server is running on configured port (`config.yaml` → `dashboard.http`)
+2. Verify React build exists in `dist/dashboard/public` (run `pnpm build:client`)
+3. Check browser console for CORS or network errors
+
+**WebSocket not connecting**:
+1. Verify Socket.io path is `/ws` (matches server config)
+2. Check `VITE_WS_URL` environment variable
+3. Review browser DevTools Network tab for WebSocket upgrade request
+
+**Permissions not appearing**:
+1. Verify `grantPermission: "forward"` in team config
+2. Check `PendingPermissionsManager` is passed to `DashboardStateBridge`
+3. Watch for `permission:request` events in browser console
+
+**Sessions not showing**:
+1. Check SessionManager database exists (`~/.iris/sessions.db`)
+2. Verify teams are configured in `config.yaml`
+3. Use `getActiveSessions()` to debug bridge data merging
+
+## Important File Paths
+
+**Relative to this directory** (`src/dashboard/`):
+- `server/index.ts` - Express server entry point
+- `server/state-bridge.ts` - Bridge between MCP internals and dashboard
+- `server/routes/processes.ts` - Session management API routes
+- `server/routes/config.ts` - Configuration management API routes
+- `client/src/App.tsx` - React app root with routing
+- `client/src/hooks/useWebSocket.ts` - WebSocket connection hook
+- `client/vite.config.ts` - Vite build configuration
+
+**Relative to parent** (`../`):
+- `process-pool/pool-manager.ts` - ClaudeProcessPool (runtime state)
+- `session/session-manager.ts` - SessionManager (persistent data)
+- `config/iris-config.ts` - TeamsConfigManager (config hot-reload)
+- `permissions/pending-manager.ts` - PendingPermissionsManager
+- `iris.ts` - IrisOrchestrator (message cache access)
diff --git a/src/dashboard/client/src/App.tsx b/src/dashboard/client/src/App.tsx
index 38a74e8..873b859 100644
--- a/src/dashboard/client/src/App.tsx
+++ b/src/dashboard/client/src/App.tsx
@@ -2,11 +2,15 @@
  * Main App component with routing
  */
 
+import { useState } from 'react';
 import { BrowserRouter, Routes, Route } from 'react-router-dom';
 import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
 import { Layout } from './components/Layout';
 import { ProcessMonitor } from './pages/ProcessMonitor';
 import { ConfigEditor } from './pages/ConfigEditor';
+import { LogViewer } from './pages/LogViewer';
+import { PermissionApprovalModal } from './components/PermissionApprovalModal';
+import { useWebSocket, type PendingPermissionRequest } from './hooks/useWebSocket';
 
 // Create a client
 const queryClient = new QueryClient({
@@ -19,6 +23,33 @@ const queryClient = new QueryClient({
 });
 
 function App() {
+  const [currentPermission, setCurrentPermission] = useState<PendingPermissionRequest | null>(null);
+
+  // WebSocket connection with permission handling
+  const { respondToPermission } = useWebSocket(
+    undefined, // onProcessStatus
+    undefined, // onCacheStream
+    (request) => {
+      // onPermissionRequest - show modal
+      setCurrentPermission(request);
+    },
+  );
+
+  const handleApprove = (permissionId: string) => {
+    respondToPermission(permissionId, true, 'Approved by user via dashboard');
+    setCurrentPermission(null);
+  };
+
+  const handleDeny = (permissionId: string) => {
+    respondToPermission(permissionId, false, 'Denied by user via dashboard');
+    setCurrentPermission(null);
+  };
+
+  const handleTimeout = () => {
+    // Just close the modal, backend will handle timeout
+    setCurrentPermission(null);
+  };
+
   return (
     <QueryClientProvider client={queryClient}>
       <BrowserRouter>
@@ -26,9 +57,18 @@ function App() {
           <Route path="/" element={<Layout />}>
             <Route index element={<ProcessMonitor />} />
             <Route path="config" element={<ConfigEditor />} />
+            <Route path="logs" element={<LogViewer />} />
           </Route>
         </Routes>
       </BrowserRouter>
+
+      {/* Global permission approval modal */}
+      <PermissionApprovalModal
+        request={currentPermission}
+        onApprove={handleApprove}
+        onDeny={handleDeny}
+        onTimeout={handleTimeout}
+      />
     </QueryClientProvider>
   );
 }
diff --git a/src/dashboard/client/src/api/client.ts b/src/dashboard/client/src/api/client.ts
index 851cd33..81fd822 100644
--- a/src/dashboard/client/src/api/client.ts
+++ b/src/dashboard/client/src/api/client.ts
@@ -56,8 +56,8 @@ export const api = {
     apiClient.post(`/processes/delete/${fromTeam}/${toTeam}`),
 
   // Terminal
-  launchTerminal: (sessionId: string, toTeam: string) =>
-    apiClient.post("/processes/terminal/launch", { sessionId, toTeam }),
+  launchTerminal: (sessionId: string) =>
+    apiClient.post("/processes/terminal/launch", { sessionId }),
 
   // Health
   getHealth: () => apiClient.get("/health"),
diff --git a/src/dashboard/client/src/components/Layout.tsx b/src/dashboard/client/src/components/Layout.tsx
index 2be1a6f..d87e6db 100644
--- a/src/dashboard/client/src/components/Layout.tsx
+++ b/src/dashboard/client/src/components/Layout.tsx
@@ -3,7 +3,7 @@
  */
 
 import { Link, Outlet, useLocation } from 'react-router-dom';
-import { Settings, Activity } from 'lucide-react';
+import { Settings, Activity, FileText } from 'lucide-react';
 import { useWebSocket } from '../hooks/useWebSocket';
 
 export function Layout() {
@@ -13,6 +13,7 @@ export function Layout() {
   const navItems = [
     { path: '/', label: 'Processes', icon: Activity },
     { path: '/config', label: 'Configuration', icon: Settings },
+    { path: '/logs', label: 'Logs', icon: FileText },
   ];
 
   return (
diff --git a/src/dashboard/client/src/components/PermissionApprovalModal.tsx b/src/dashboard/client/src/components/PermissionApprovalModal.tsx
new file mode 100644
index 0000000..e725fc3
--- /dev/null
+++ b/src/dashboard/client/src/components/PermissionApprovalModal.tsx
@@ -0,0 +1,143 @@
+/**
+ * Permission Approval Modal
+ * Simple popup that displays permission requests and auto-dismisses after 60s
+ */
+
+import { useEffect, useState } from 'react';
+import { AlertTriangle, CheckCircle, XCircle } from 'lucide-react';
+import type { PendingPermissionRequest } from '../hooks/useWebSocket';
+
+interface PermissionApprovalModalProps {
+  request: PendingPermissionRequest | null;
+  onApprove: (permissionId: string) => void;
+  onDeny: (permissionId: string) => void;
+  onTimeout: () => void;
+}
+
+export function PermissionApprovalModal({
+  request,
+  onApprove,
+  onDeny,
+  onTimeout,
+}: PermissionApprovalModalProps) {
+  const [timeRemaining, setTimeRemaining] = useState(60);
+
+  useEffect(() => {
+    if (!request) {
+      setTimeRemaining(60);
+      return;
+    }
+
+    // Countdown timer
+    const interval = setInterval(() => {
+      setTimeRemaining((prev) => {
+        if (prev <= 1) {
+          clearInterval(interval);
+          onTimeout();
+          return 0;
+        }
+        return prev - 1;
+      });
+    }, 1000);
+
+    return () => clearInterval(interval);
+  }, [request, onTimeout]);
+
+  if (!request) {
+    return null;
+  }
+
+  const handleApprove = () => {
+    onApprove(request.permissionId);
+  };
+
+  const handleDeny = () => {
+    onDeny(request.permissionId);
+  };
+
+  return (
+    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50 backdrop-blur-sm">
+      <div className="bg-white dark:bg-gray-800 rounded-lg shadow-2xl max-w-2xl w-full mx-4 max-h-[90vh] overflow-hidden flex flex-col">
+        {/* Header */}
+        <div className="bg-gradient-to-r from-yellow-500 to-orange-500 px-6 py-4 flex items-center justify-between">
+          <div className="flex items-center gap-3">
+            <AlertTriangle className="w-6 h-6 text-white" />
+            <h2 className="text-xl font-semibold text-white">Permission Request</h2>
+          </div>
+          <div className="flex items-center gap-3">
+            <div className="bg-white bg-opacity-20 rounded-full px-3 py-1 text-white text-sm font-medium">
+              {timeRemaining}s
+            </div>
+          </div>
+        </div>
+
+        {/* Content */}
+        <div className="p-6 overflow-y-auto flex-1">
+          <div className="space-y-4">
+            {/* Team Info */}
+            <div>
+              <label className="text-sm font-medium text-gray-500 dark:text-gray-400">Team</label>
+              <div className="mt-1 text-lg font-semibold text-gray-900 dark:text-white">
+                {request.teamName}
+              </div>
+            </div>
+
+            {/* Tool Info */}
+            <div>
+              <label className="text-sm font-medium text-gray-500 dark:text-gray-400">Tool</label>
+              <div className="mt-1 font-mono text-sm bg-gray-100 dark:bg-gray-900 px-3 py-2 rounded">
+                {request.toolName}
+              </div>
+            </div>
+
+            {/* Reason */}
+            {request.reason && (
+              <div>
+                <label className="text-sm font-medium text-gray-500 dark:text-gray-400">Reason</label>
+                <div className="mt-1 text-gray-900 dark:text-white">
+                  {request.reason}
+                </div>
+              </div>
+            )}
+
+            {/* Tool Input */}
+            <div>
+              <label className="text-sm font-medium text-gray-500 dark:text-gray-400">Input Parameters</label>
+              <div className="mt-1 bg-gray-100 dark:bg-gray-900 rounded p-3 max-h-64 overflow-y-auto">
+                <pre className="text-xs font-mono text-gray-800 dark:text-gray-200 whitespace-pre-wrap">
+                  {JSON.stringify(request.toolInput, null, 2)}
+                </pre>
+              </div>
+            </div>
+
+            {/* Session ID */}
+            <div>
+              <label className="text-sm font-medium text-gray-500 dark:text-gray-400">Session ID</label>
+              <div className="mt-1 font-mono text-xs text-gray-600 dark:text-gray-400">
+                {request.sessionId}
+              </div>
+            </div>
+          </div>
+        </div>
+
+        {/* Footer */}
+        <div className="bg-gray-50 dark:bg-gray-900 px-6 py-4 flex items-center justify-end gap-3">
+          <button
+            onClick={handleDeny}
+            className="flex items-center gap-2 px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded-lg font-medium transition-colors"
+          >
+            <XCircle className="w-4 h-4" />
+            Deny
+          </button>
+          <button
+            onClick={handleApprove}
+            className="flex items-center gap-2 px-4 py-2 bg-green-600 hover:bg-green-700 text-white rounded-lg font-medium transition-colors"
+          >
+            <CheckCircle className="w-4 h-4" />
+            Approve
+          </button>
+        </div>
+      </div>
+    </div>
+  );
+}
diff --git a/src/dashboard/client/src/hooks/useWebSocket.ts b/src/dashboard/client/src/hooks/useWebSocket.ts
index ad8c149..8704048 100644
--- a/src/dashboard/client/src/hooks/useWebSocket.ts
+++ b/src/dashboard/client/src/hooks/useWebSocket.ts
@@ -29,15 +29,58 @@ export interface CacheStreamData {
   timestamp: number;
 }
 
+export interface PendingPermissionRequest {
+  permissionId: string;
+  sessionId: string;
+  teamName: string;
+  toolName: string;
+  toolInput: Record<string, unknown>;
+  reason?: string;
+  createdAt: string;
+}
+
+export interface ParsedLogEntry {
+  timestamp: number;
+  level: string;
+  context?: string;
+  message: string;
+  [key: string]: any;
+}
+
+export interface LogBatchData {
+  logs: ParsedLogEntry[];
+  storeName?: string;
+  timestamp: number;
+}
+
 export interface WebSocketState {
   connected: boolean;
   socket: Socket | null;
 }
 
-export function useWebSocket(onProcessStatus?: (data: ProcessStatus) => void, onCacheStream?: (data: CacheStreamData) => void) {
+export function useWebSocket(
+  onProcessStatus?: (data: ProcessStatus) => void,
+  onCacheStream?: (data: CacheStreamData) => void,
+  onPermissionRequest?: (data: PendingPermissionRequest) => void,
+  onLogBatch?: (data: LogBatchData) => void,
+) {
   const socketRef = useRef<Socket | null>(null);
   const [connected, setConnected] = useState(false);
 
+  // Store callbacks in refs so they can be updated without reconnecting
+  const onProcessStatusRef = useRef(onProcessStatus);
+  const onCacheStreamRef = useRef(onCacheStream);
+  const onPermissionRequestRef = useRef(onPermissionRequest);
+  const onLogBatchRef = useRef(onLogBatch);
+
+  // Update refs on each render
+  useEffect(() => {
+    onProcessStatusRef.current = onProcessStatus;
+    onCacheStreamRef.current = onCacheStream;
+    onPermissionRequestRef.current = onPermissionRequest;
+    onLogBatchRef.current = onLogBatch;
+  });
+
   useEffect(() => {
     // Connect to WebSocket
     const socket = io(WS_URL, {
@@ -63,15 +106,15 @@ export function useWebSocket(onProcessStatus?: (data: ProcessStatus) => void, on
 
     socket.on('process-status', (data: ProcessStatus) => {
       console.log('[WebSocket] Process status update', data);
-      if (onProcessStatus) {
-        onProcessStatus(data);
+      if (onProcessStatusRef.current) {
+        onProcessStatusRef.current(data);
       }
     });
 
     socket.on('cache-stream', (data: CacheStreamData) => {
       console.log('[WebSocket] Cache stream data', data);
-      if (onCacheStream) {
-        onCacheStream(data);
+      if (onCacheStreamRef.current) {
+        onCacheStreamRef.current(data);
       }
     });
 
@@ -79,6 +122,37 @@ export function useWebSocket(onProcessStatus?: (data: ProcessStatus) => void, on
       console.log('[WebSocket] Config saved', data);
     });
 
+    socket.on('permission:request', (data: PendingPermissionRequest) => {
+      console.log('[WebSocket] Permission request', data);
+      if (onPermissionRequestRef.current) {
+        onPermissionRequestRef.current(data);
+      }
+    });
+
+    socket.on('permission:resolved', (data: any) => {
+      console.log('[WebSocket] Permission resolved', data);
+    });
+
+    socket.on('permission:timeout', (data: any) => {
+      console.log('[WebSocket] Permission timeout', data);
+    });
+
+    // Log streaming events
+    socket.on('logs:batch', (data: LogBatchData) => {
+      console.log('[WebSocket] Log batch received', data.logs.length, 'logs');
+      if (onLogBatchRef.current) {
+        onLogBatchRef.current(data);
+      }
+    });
+
+    socket.on('logs:stores', (data: { stores: string[] }) => {
+      console.log('[WebSocket] Log stores', data.stores);
+    });
+
+    socket.on('logs:error', (error: { message: string }) => {
+      console.error('[WebSocket] Log error', error);
+    });
+
     socket.on('error', (error: any) => {
       console.error('[WebSocket] Error', error);
     });
@@ -87,7 +161,7 @@ export function useWebSocket(onProcessStatus?: (data: ProcessStatus) => void, on
     return () => {
       socket.disconnect();
     };
-  }, [onProcessStatus, onCacheStream]);
+  }, []); // Empty deps - connect once, callbacks updated via refs
 
   const streamCache = (sessionId: string) => {
     if (socketRef.current && connected) {
@@ -96,9 +170,45 @@ export function useWebSocket(onProcessStatus?: (data: ProcessStatus) => void, on
     }
   };
 
+  const respondToPermission = (permissionId: string, approved: boolean, reason?: string) => {
+    if (socketRef.current && connected) {
+      console.log('[WebSocket] Responding to permission', { permissionId, approved, reason });
+      socketRef.current.emit('permission:response', {
+        permissionId,
+        approved,
+        reason,
+      });
+    }
+  };
+
+  const startLogStream = (options?: { storeName?: string; level?: string | string[] }) => {
+    if (socketRef.current && connected) {
+      console.log('[WebSocket] Starting log stream', options);
+      socketRef.current.emit('logs:start', options || {});
+    }
+  };
+
+  const stopLogStream = () => {
+    if (socketRef.current && connected) {
+      console.log('[WebSocket] Stopping log stream');
+      socketRef.current.emit('logs:stop');
+    }
+  };
+
+  const getLogStores = () => {
+    if (socketRef.current && connected) {
+      console.log('[WebSocket] Requesting log stores');
+      socketRef.current.emit('logs:get-stores');
+    }
+  };
+
   return {
     connected,
     socket: socketRef.current,
     streamCache,
+    respondToPermission,
+    startLogStream,
+    stopLogStream,
+    getLogStores,
   };
 }
diff --git a/src/dashboard/client/src/pages/LogViewer.tsx b/src/dashboard/client/src/pages/LogViewer.tsx
new file mode 100644
index 0000000..29dbc21
--- /dev/null
+++ b/src/dashboard/client/src/pages/LogViewer.tsx
@@ -0,0 +1,302 @@
+/**
+ * LogViewer Page
+ * Real-time log streaming from wonder-logger memory transport
+ */
+
+import { useState, useEffect, useRef } from 'react';
+import { useWebSocket, type ParsedLogEntry, type LogBatchData } from '../hooks/useWebSocket';
+
+const LOG_LEVELS = ['trace', 'debug', 'info', 'warn', 'error', 'fatal'] as const;
+
+const LEVEL_COLORS: Record<string, string> = {
+  trace: 'text-gray-500',
+  debug: 'text-blue-400',
+  info: 'text-green-400',
+  warn: 'text-yellow-400',
+  error: 'text-red-400',
+  fatal: 'text-red-600 font-bold',
+};
+
+const LEVEL_BG_COLORS: Record<string, string> = {
+  trace: 'bg-gray-500/10',
+  debug: 'bg-blue-500/10',
+  info: 'bg-green-500/10',
+  warn: 'bg-yellow-500/10',
+  error: 'bg-red-500/10',
+  fatal: 'bg-red-600/20',
+};
+
+export function LogViewer() {
+  const [logs, setLogs] = useState<ParsedLogEntry[]>([]);
+  const [isStreaming, setIsStreaming] = useState(false);
+  const [selectedLevels, setSelectedLevels] = useState<string[]>([]);
+  const [autoScroll, setAutoScroll] = useState(true);
+  const [filter, setFilter] = useState('');
+  const logsEndRef = useRef<HTMLDivElement>(null);
+  const logsContainerRef = useRef<HTMLDivElement>(null);
+
+  // Handle log batch updates
+  const handleLogBatch = (data: LogBatchData) => {
+    setLogs((prev) => [...prev, ...data.logs]);
+  };
+
+  const { connected, startLogStream, stopLogStream } = useWebSocket(
+    undefined, // onProcessStatus
+    undefined, // onCacheStream
+    undefined, // onPermissionRequest
+    handleLogBatch, // onLogBatch
+  );
+
+  // Auto-scroll to bottom when new logs arrive
+  useEffect(() => {
+    if (autoScroll && logsEndRef.current) {
+      logsEndRef.current.scrollIntoView({ behavior: 'smooth' });
+    }
+  }, [logs, autoScroll]);
+
+  // Start streaming on mount if connected
+  useEffect(() => {
+    if (connected && !isStreaming) {
+      handleStartStreaming();
+    }
+
+    // Stop streaming on unmount
+    return () => {
+      if (isStreaming) {
+        stopLogStream();
+      }
+    };
+  }, [connected]);
+
+  const handleStartStreaming = () => {
+    const options = selectedLevels.length > 0 ? { level: selectedLevels } : undefined;
+    startLogStream(options);
+    setIsStreaming(true);
+  };
+
+  const handleStopStreaming = () => {
+    stopLogStream();
+    setIsStreaming(false);
+  };
+
+  const handleClearLogs = () => {
+    setLogs([]);
+  };
+
+  const handleToggleLevel = (level: string) => {
+    setSelectedLevels((prev) =>
+      prev.includes(level)
+        ? prev.filter((l) => l !== level)
+        : [...prev, level]
+    );
+  };
+
+  const handleApplyFilter = () => {
+    if (isStreaming) {
+      handleStopStreaming();
+    }
+    handleStartStreaming();
+  };
+
+  // Filter logs by search text
+  const filteredLogs = logs.filter((log) => {
+    if (!filter) return true;
+    const searchText = filter.toLowerCase();
+    return (
+      log.message?.toLowerCase().includes(searchText) ||
+      log.context?.toLowerCase().includes(searchText) ||
+      JSON.stringify(log).toLowerCase().includes(searchText)
+    );
+  });
+
+  // Format timestamp
+  const formatTime = (timestamp: number) => {
+    const date = new Date(timestamp);
+    const hours = String(date.getHours()).padStart(2, '0');
+    const minutes = String(date.getMinutes()).padStart(2, '0');
+    const seconds = String(date.getSeconds()).padStart(2, '0');
+    const milliseconds = String(date.getMilliseconds()).padStart(3, '0');
+    return `${hours}:${minutes}:${seconds}.${milliseconds}`;
+  };
+
+  return (
+    <div className="flex flex-col h-full">
+      {/* Header */}
+      <div className="bg-gray-800 border-b border-gray-700 p-4">
+        <h1 className="text-2xl font-bold text-white mb-4">Wonder Logger Stream</h1>
+
+        {/* Controls */}
+        <div className="flex flex-wrap gap-3 items-center">
+          {/* Stream Control */}
+          <div className="flex gap-2">
+            {!isStreaming ? (
+              <button
+                onClick={handleStartStreaming}
+                disabled={!connected}
+                className="px-4 py-2 bg-green-600 hover:bg-green-700 disabled:bg-gray-600 disabled:cursor-not-allowed text-white rounded font-medium transition-colors"
+              >
+                Start Streaming
+              </button>
+            ) : (
+              <button
+                onClick={handleStopStreaming}
+                className="px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded font-medium transition-colors"
+              >
+                Stop Streaming
+              </button>
+            )}
+
+            <button
+              onClick={handleClearLogs}
+              className="px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white rounded font-medium transition-colors"
+            >
+              Clear Logs
+            </button>
+          </div>
+
+          {/* Level Filters */}
+          <div className="flex gap-2 items-center">
+            <span className="text-gray-400 text-sm">Levels:</span>
+            {LOG_LEVELS.map((level) => (
+              <button
+                key={level}
+                onClick={() => handleToggleLevel(level)}
+                className={`px-3 py-1 rounded text-sm font-medium transition-colors ${
+                  selectedLevels.includes(level) || selectedLevels.length === 0
+                    ? `${LEVEL_BG_COLORS[level]} ${LEVEL_COLORS[level]} border-2 border-current`
+                    : 'bg-gray-700 text-gray-500 border-2 border-transparent'
+                }`}
+              >
+                {level}
+              </button>
+            ))}
+            {selectedLevels.length > 0 && (
+              <button
+                onClick={handleApplyFilter}
+                className="px-3 py-1 bg-blue-600 hover:bg-blue-700 text-white rounded text-sm font-medium transition-colors"
+              >
+                Apply Filter
+              </button>
+            )}
+          </div>
+
+          {/* Auto-scroll Toggle */}
+          <label className="flex items-center gap-2 text-gray-400 cursor-pointer">
+            <input
+              type="checkbox"
+              checked={autoScroll}
+              onChange={(e) => setAutoScroll(e.target.checked)}
+              className="w-4 h-4"
+            />
+            <span className="text-sm">Auto-scroll</span>
+          </label>
+
+          {/* Connection Status */}
+          <div className="ml-auto flex items-center gap-2">
+            <div
+              className={`w-2 h-2 rounded-full ${
+                connected ? 'bg-green-500' : 'bg-red-500'
+              }`}
+            />
+            <span className="text-sm text-gray-400">
+              {connected ? 'Connected' : 'Disconnected'}
+            </span>
+            {isStreaming && (
+              <span className="text-sm text-green-400 animate-pulse">● Streaming</span>
+            )}
+          </div>
+        </div>
+
+        {/* Search Filter */}
+        <div className="mt-3">
+          <input
+            type="text"
+            value={filter}
+            onChange={(e) => setFilter(e.target.value)}
+            placeholder="Filter logs by message, context, or any field..."
+            className="w-full px-3 py-2 bg-gray-700 text-white rounded border border-gray-600 focus:border-blue-500 focus:outline-none"
+          />
+        </div>
+
+        {/* Stats */}
+        <div className="mt-3 flex gap-4 text-sm text-gray-400">
+          <span>Total: {logs.length}</span>
+          <span>Filtered: {filteredLogs.length}</span>
+        </div>
+      </div>
+
+      {/* Logs Container */}
+      <div
+        ref={logsContainerRef}
+        className="flex-1 overflow-auto bg-gray-900 p-4 font-mono text-sm"
+      >
+        {filteredLogs.length === 0 ? (
+          <div className="text-center text-gray-500 py-12">
+            {logs.length === 0 ? (
+              <div>
+                <p className="text-lg mb-2">No logs yet</p>
+                <p className="text-sm">
+                  {isStreaming ? 'Waiting for log entries...' : 'Start streaming to view logs'}
+                </p>
+              </div>
+            ) : (
+              <p>No logs match the current filter</p>
+            )}
+          </div>
+        ) : (
+          <>
+            {filteredLogs.map((log, index) => (
+              <div
+                key={`${log.timestamp}-${index}`}
+                className={`mb-1 p-2 rounded ${LEVEL_BG_COLORS[log.level] || 'bg-gray-800'}`}
+              >
+                <div className="flex items-start gap-3">
+                  {/* Timestamp */}
+                  <span className="text-gray-500 flex-shrink-0 text-xs">
+                    {formatTime(log.timestamp)}
+                  </span>
+
+                  {/* Level */}
+                  <span
+                    className={`${LEVEL_COLORS[log.level] || 'text-gray-400'} flex-shrink-0 font-bold uppercase text-xs w-12`}
+                  >
+                    {log.level}
+                  </span>
+
+                  {/* Context */}
+                  {log.context && (
+                    <span className="text-purple-400 flex-shrink-0 text-xs">
+                      [{log.context}]
+                    </span>
+                  )}
+
+                  {/* Message */}
+                  <span className="text-gray-200 flex-1 break-words">{log.message}</span>
+                </div>
+
+                {/* Additional Fields */}
+                {Object.keys(log).filter(
+                  (key) => !['timestamp', 'level', 'context', 'message'].includes(key)
+                ).length > 0 && (
+                  <div className="mt-1 ml-14 text-gray-400 text-xs">
+                    {Object.entries(log)
+                      .filter(([key]) => !['timestamp', 'level', 'context', 'message'].includes(key))
+                      .map(([key, value]) => (
+                        <div key={key} className="truncate">
+                          <span className="text-gray-500">{key}:</span>{' '}
+                          {typeof value === 'object'
+                            ? JSON.stringify(value)
+                            : String(value)}
+                        </div>
+                      ))}
+                  </div>
+                )}
+              </div>
+            ))}
+            <div ref={logsEndRef} />
+          </>
+        )}
+      </div>
+    </div>
+  );
+}
diff --git a/src/dashboard/client/src/pages/ProcessMonitor.tsx b/src/dashboard/client/src/pages/ProcessMonitor.tsx
index bfc0e4b..27fd83f 100644
--- a/src/dashboard/client/src/pages/ProcessMonitor.tsx
+++ b/src/dashboard/client/src/pages/ProcessMonitor.tsx
@@ -44,6 +44,10 @@ interface SessionProcessInfo {
   uptime: number;
   queueLength: number;
   lastResponseAt: number | null;
+
+  // Debug info (for troubleshooting)
+  launchCommand: string | null;
+  teamConfigSnapshot: string | null;
 }
 
 function getStatusColor(status: string): string {
@@ -100,6 +104,7 @@ export function ProcessMonitor() {
       | "success"
       | "error";
   }>({});
+  const [expandedDebug, setExpandedDebug] = useState<Set<string>>(new Set());
   const dropdownRef = useRef<HTMLDivElement>(null);
 
   // Handle WebSocket updates
@@ -237,11 +242,11 @@ export function ProcessMonitor() {
   }, []);
 
   const handleLaunchTerminal = useCallback(
-    async (sessionId: string, toTeam: string) => {
+    async (sessionId: string) => {
       setTerminalStatus((prev) => ({ ...prev, [sessionId]: "launching" }));
 
       try {
-        const response = await api.launchTerminal(sessionId, toTeam);
+        const response = await api.launchTerminal(sessionId);
 
         if (response.data.success) {
           // Success - terminal launched
@@ -275,8 +280,7 @@ export function ProcessMonitor() {
         console.error("Failed to launch terminal:", error);
         alert(
           `Failed to launch terminal: ${errorMsg}\n\n` +
-            `Session ID: ${sessionId}\n` +
-            `Team: ${toTeam}\n\n` +
+            `Session ID: ${sessionId}\n\n` +
             "You can manually run:\n" +
             `claude --resume ${sessionId}`,
         );
@@ -587,7 +591,7 @@ export function ProcessMonitor() {
                   {terminalScriptAvailable && (
                     <button
                       onClick={() =>
-                        handleLaunchTerminal(session.sessionId, session.toTeam)
+                        handleLaunchTerminal(session.sessionId)
                       }
                       disabled={
                         terminalStatus[session.sessionId] === "launching"
@@ -620,6 +624,56 @@ export function ProcessMonitor() {
                   )}
                 </div>
               )}
+
+              {/* Debug Info Section */}
+              {session.launchCommand && (
+                <div className="mt-4 border-t border-gray-700 pt-4">
+                  <button
+                    onClick={() => {
+                      const newExpanded = new Set(expandedDebug);
+                      if (newExpanded.has(session.poolKey)) {
+                        newExpanded.delete(session.poolKey);
+                      } else {
+                        newExpanded.add(session.poolKey);
+                      }
+                      setExpandedDebug(newExpanded);
+                    }}
+                    className="flex items-center gap-2 text-sm text-text-secondary hover:text-accent-purple transition-colors"
+                  >
+                    <span className="font-mono">
+                      {expandedDebug.has(session.poolKey) ? "▼" : "▶"}
+                    </span>
+                    <span>Debug Info</span>
+                  </button>
+
+                  {expandedDebug.has(session.poolKey) && (
+                    <div className="mt-2 space-y-3">
+                      <div>
+                        <label className="text-xs text-text-secondary uppercase tracking-wide">
+                          Launch Command
+                        </label>
+                        <pre className="mt-1 p-2 bg-bg-dark rounded text-xs font-mono text-green-400 overflow-x-auto">
+                          {session.launchCommand}
+                        </pre>
+                      </div>
+                      {session.teamConfigSnapshot && (
+                        <div>
+                          <label className="text-xs text-text-secondary uppercase tracking-wide">
+                            Team Config (Server-Side)
+                          </label>
+                          <pre className="mt-1 p-2 bg-bg-dark rounded text-xs font-mono text-blue-400 overflow-x-auto max-h-60 overflow-y-auto">
+                            {JSON.stringify(
+                              JSON.parse(session.teamConfigSnapshot),
+                              null,
+                              2,
+                            )}
+                          </pre>
+                        </div>
+                      )}
+                    </div>
+                  )}
+                </div>
+              )}
             </div>
           ))}
         </div>
diff --git a/src/dashboard/server/index.ts b/src/dashboard/server/index.ts
index 6d66bc4..3b5a09d 100644
--- a/src/dashboard/server/index.ts
+++ b/src/dashboard/server/index.ts
@@ -162,6 +162,7 @@ export async function startDashboardServer(
       sessions: bridge.getActiveSessions(),
       poolStatus: bridge.getPoolStatus(),
       config: bridge.getConfig(),
+      pendingPermissions: bridge.getPendingPermissions(),
     });
 
     // Subscribe to process status updates
@@ -177,10 +178,26 @@ export async function startDashboardServer(
       socket.emit('cache-stream', data);
     };
 
+    // Subscribe to permission events
+    const permissionRequestHandler = (data: any) => {
+      socket.emit('permission:request', data);
+    };
+
+    const permissionResolvedHandler = (data: any) => {
+      socket.emit('permission:resolved', data);
+    };
+
+    const permissionTimeoutHandler = (data: any) => {
+      socket.emit('permission:timeout', data);
+    };
+
     // Register event handlers
     bridge.on('ws:process-status', processStatusHandler);
     bridge.on('ws:config-saved', configSavedHandler);
     bridge.on('ws:cache-stream', cacheStreamHandler);
+    bridge.on('ws:permission:request', permissionRequestHandler);
+    bridge.on('ws:permission:resolved', permissionResolvedHandler);
+    bridge.on('ws:permission:timeout', permissionTimeoutHandler);
 
     // Handle client requests to stream cache for a specific session
     socket.on('stream-cache', (sessionId: string) => {
@@ -194,16 +211,170 @@ export async function startDashboardServer(
       }
     });
 
+    // Handle permission responses from dashboard
+    socket.on('permission:response', (data: {
+      permissionId: string;
+      approved: boolean;
+      reason?: string;
+    }) => {
+      logger.info({
+        socketId: socket.id,
+        permissionId: data.permissionId,
+        approved: data.approved,
+      }, 'Received permission response from dashboard');
+
+      const success = bridge.resolvePermission(
+        data.permissionId,
+        data.approved,
+        data.reason,
+      );
+
+      if (!success) {
+        logger.warn({
+          socketId: socket.id,
+          permissionId: data.permissionId,
+        }, 'Failed to resolve permission - may have already timed out');
+
+        socket.emit('permission:error', {
+          permissionId: data.permissionId,
+          message: 'Permission already resolved or timed out',
+        });
+      }
+    });
+
+    // Log streaming state
+    let logStreamInterval: NodeJS.Timeout | null = null;
+    let lastLogTimestamp = Date.now();
+
+    // Handle log stream requests
+    socket.on('logs:start', async (data: {
+      storeName?: string;
+      level?: string | string[];
+    }) => {
+      logger.info({
+        socketId: socket.id,
+        storeName: data.storeName,
+        level: data.level,
+      }, 'Client requested log stream');
+
+      // Clear existing interval if any
+      if (logStreamInterval) {
+        clearInterval(logStreamInterval);
+      }
+
+      // Reset timestamp to get all logs initially
+      lastLogTimestamp = Date.now() - (60 * 1000); // Start from 1 minute ago
+
+      // Send initial batch of logs
+      try {
+        const result = await bridge.getLogs({
+          since: lastLogTimestamp,
+          storeName: data.storeName,
+          format: 'parsed',
+          level: data.level,
+        });
+
+        socket.emit('logs:batch', {
+          logs: result.logs || [],
+          storeName: result.storeName,
+          timestamp: result.timestamp,
+        });
+
+        // Update timestamp for next poll
+        // Add 1ms to exclude the last log we just sent (wonder-logger uses >= not >)
+        if (result.logs && result.logs.length > 0) {
+          const lastLog = result.logs[result.logs.length - 1];
+          lastLogTimestamp = (lastLog.timestamp || Date.now()) + 1;
+        }
+      } catch (error: any) {
+        logger.error({
+          err: error instanceof Error ? error : new Error(String(error)),
+          socketId: socket.id,
+        }, 'Failed to get initial logs');
+
+        socket.emit('logs:error', {
+          message: error.message || 'Failed to retrieve logs',
+        });
+      }
+
+      // Start polling for new logs every 1 second
+      logStreamInterval = setInterval(async () => {
+        try {
+          const result = await bridge.getLogs({
+            since: lastLogTimestamp,
+            storeName: data.storeName,
+            format: 'parsed',
+            level: data.level,
+          });
+
+          // Only emit if there are new logs
+          if (result.logs && result.logs.length > 0) {
+            socket.emit('logs:batch', {
+              logs: result.logs,
+              storeName: result.storeName,
+              timestamp: result.timestamp,
+            });
+
+            // Update timestamp for next poll
+            // Add 1ms to exclude the last log we just sent (wonder-logger uses >= not >)
+            const lastLog = result.logs[result.logs.length - 1];
+            lastLogTimestamp = (lastLog.timestamp || Date.now()) + 1;
+          }
+        } catch (error: any) {
+          logger.error({
+            err: error instanceof Error ? error : new Error(String(error)),
+            socketId: socket.id,
+          }, 'Failed to poll logs');
+        }
+      }, 1000); // Poll every second
+    });
+
+    // Handle log stream stop
+    socket.on('logs:stop', () => {
+      logger.info({ socketId: socket.id }, 'Client stopped log stream');
+
+      if (logStreamInterval) {
+        clearInterval(logStreamInterval);
+        logStreamInterval = null;
+      }
+    });
+
+    // Get available log stores
+    socket.on('logs:get-stores', async () => {
+      try {
+        const stores = await bridge.getLogStores();
+        socket.emit('logs:stores', { stores });
+      } catch (error: any) {
+        logger.error({
+          err: error instanceof Error ? error : new Error(String(error)),
+          socketId: socket.id,
+        }, 'Failed to get log stores');
+
+        socket.emit('logs:error', {
+          message: error.message || 'Failed to retrieve log stores',
+        });
+      }
+    });
+
     // Handle disconnection
     socket.on('disconnect', () => {
       logger.info({
         socketId: socket.id,
       }, 'Dashboard client disconnected');
 
+      // Clean up log streaming
+      if (logStreamInterval) {
+        clearInterval(logStreamInterval);
+        logStreamInterval = null;
+      }
+
       // Clean up event handlers
       bridge.off('ws:process-status', processStatusHandler);
       bridge.off('ws:config-saved', configSavedHandler);
       bridge.off('ws:cache-stream', cacheStreamHandler);
+      bridge.off('ws:permission:request', permissionRequestHandler);
+      bridge.off('ws:permission:resolved', permissionResolvedHandler);
+      bridge.off('ws:permission:timeout', permissionTimeoutHandler);
     });
   });
 
diff --git a/src/dashboard/server/routes/processes.ts b/src/dashboard/server/routes/processes.ts
index 3181108..ef21490 100644
--- a/src/dashboard/server/routes/processes.ts
+++ b/src/dashboard/server/routes/processes.ts
@@ -201,26 +201,26 @@ export function createProcessesRouter(bridge: DashboardStateBridge): Router {
    */
   router.post("/terminal/launch", async (req, res) => {
     try {
-      const { sessionId, toTeam, fromTeam = "dashboard" } = req.body;
+      const { sessionId } = req.body;
 
-      if (!toTeam) {
+      if (!sessionId) {
         return res.status(400).json({
           success: false,
-          error: "Missing required field: toTeam",
+          error: "Missing required field: sessionId",
         });
       }
 
       logger.info(
-        { toTeam, fromTeam, sessionId },
+        { sessionId },
         "Dashboard requesting terminal fork via MCP action",
       );
 
       try {
         // Use the fork MCP action (same logic as MCP clients)
-        const result = await bridge.forkSession(fromTeam, toTeam);
+        const result = await bridge.forkSessionById(sessionId);
 
         logger.info(
-          { toTeam, fromTeam, result },
+          { sessionId, result },
           "Terminal fork launched successfully via MCP action",
         );
 
@@ -237,8 +237,7 @@ export function createProcessesRouter(bridge: DashboardStateBridge): Router {
               forkError instanceof Error
                 ? forkError
                 : new Error(String(forkError)),
-            toTeam,
-            fromTeam,
+            sessionId,
           },
           "Failed to fork session via MCP action",
         );
diff --git a/src/dashboard/server/state-bridge.ts b/src/dashboard/server/state-bridge.ts
index 09ef205..80d3825 100644
--- a/src/dashboard/server/state-bridge.ts
+++ b/src/dashboard/server/state-bridge.ts
@@ -16,6 +16,7 @@ import type { TeamsConfigManager } from "../../config/iris-config.js";
 import type { TeamsConfig } from "../../process-pool/types.js";
 import { PoolEvent } from "../../process-pool/types.js";
 import { IrisOrchestrator } from "../../iris.js";
+import type { PendingPermissionsManager } from "../../permissions/pending-manager.js";
 import { getChildLogger } from "../../utils/logger.js";
 
 const logger = getChildLogger("dashboard:state");
@@ -43,6 +44,10 @@ export interface SessionProcessInfo {
   uptime: number; // Process uptime (0 if stopped)
   queueLength: number; // Process queue length (0 if stopped)
   lastResponseAt: number | null; // Last response timestamp
+
+  // Debug info (for troubleshooting)
+  launchCommand: string | null; // Full command used to spawn this session
+  teamConfigSnapshot: string | null; // JSON snapshot of server-side config
 }
 
 /**
@@ -51,12 +56,14 @@ export interface SessionProcessInfo {
  */
 export class DashboardStateBridge extends EventEmitter {
   private iris: IrisOrchestrator;
+  private pendingPermissions?: PendingPermissionsManager;
 
   constructor(
     private pool: ClaudeProcessPool,
     private sessionManager: SessionManager,
     private configManager: TeamsConfigManager,
     iris?: IrisOrchestrator,
+    pendingPermissions?: PendingPermissionsManager,
   ) {
     super();
 
@@ -69,6 +76,9 @@ export class DashboardStateBridge extends EventEmitter {
         this.configManager.getConfig(),
       );
 
+    // Store permissions manager if provided
+    this.pendingPermissions = pendingPermissions;
+
     this.setupEventForwarding();
   }
 
@@ -98,6 +108,45 @@ export class DashboardStateBridge extends EventEmitter {
       },
     );
 
+    // Forward permission events if manager is available
+    if (this.pendingPermissions) {
+      this.pendingPermissions.on("permission:created", (request) => {
+        logger.debug(
+          {
+            permissionId: request.permissionId,
+            teamName: request.teamName,
+            toolName: request.toolName,
+          },
+          "Forwarding permission:created event",
+        );
+        this.emit("ws:permission:request", request);
+      });
+
+      this.pendingPermissions.on("permission:resolved", (data) => {
+        logger.debug(
+          {
+            permissionId: data.permissionId,
+            approved: data.approved,
+          },
+          "Forwarding permission:resolved event",
+        );
+        this.emit("ws:permission:resolved", data);
+      });
+
+      this.pendingPermissions.on("permission:timeout", (data) => {
+        logger.debug(
+          {
+            permissionId: data.permissionId,
+          },
+          "Forwarding permission:timeout event",
+        );
+        this.emit("ws:permission:timeout", {
+          permissionId: data.permissionId,
+          request: data.request,
+        });
+      });
+    }
+
     logger.info("Event forwarding initialized");
   }
 
@@ -167,6 +216,10 @@ export class DashboardStateBridge extends EventEmitter {
         uptime: processInfo?.uptime || 0,
         queueLength: processInfo?.queueLength || 0,
         lastResponseAt: session.lastResponseAt,
+
+        // Debug info (for troubleshooting)
+        launchCommand: session.launchCommand,
+        teamConfigSnapshot: session.teamConfigSnapshot,
       });
     }
 
@@ -222,6 +275,10 @@ export class DashboardStateBridge extends EventEmitter {
       uptime: processInfo?.uptime || 0,
       queueLength: processInfo?.queueLength || 0,
       lastResponseAt: session.lastResponseAt,
+
+      // Debug info (for troubleshooting)
+      launchCommand: session.launchCommand,
+      teamConfigSnapshot: session.teamConfigSnapshot,
     };
   }
 
@@ -465,4 +522,81 @@ export class DashboardStateBridge extends EventEmitter {
       this.configManager,
     );
   }
+
+  /**
+   * Fork a session by sessionId (lookup fromTeam/toTeam automatically)
+   * More convenient API that doesn't require caller to know the team pair
+   */
+  async forkSessionById(sessionId: string): Promise<any> {
+    // Look up session to get fromTeam and toTeam
+    const session = this.sessionManager.getSessionById(sessionId);
+
+    if (!session) {
+      throw new Error(`Session not found: ${sessionId}`);
+    }
+
+    if (!session.fromTeam) {
+      throw new Error(`Session ${sessionId} has no fromTeam (legacy session)`);
+    }
+
+    // Delegate to existing fork method
+    return await this.forkSession(session.fromTeam, session.toTeam);
+  }
+
+  /**
+   * Get all pending permission requests
+   */
+  getPendingPermissions() {
+    if (!this.pendingPermissions) {
+      return [];
+    }
+    return this.pendingPermissions.getPendingRequests();
+  }
+
+  /**
+   * Resolve a pending permission request
+   */
+  resolvePermission(
+    permissionId: string,
+    approved: boolean,
+    reason?: string,
+  ): boolean {
+    if (!this.pendingPermissions) {
+      logger.warn("Cannot resolve permission - manager not available");
+      return false;
+    }
+    return this.pendingPermissions.resolvePendingPermission(
+      permissionId,
+      approved,
+      reason,
+    );
+  }
+
+  /**
+   * Get logs from wonder-logger memory transport
+   * Delegates to the debug MCP action
+   */
+  async getLogs(options: {
+    since?: number;
+    storeName?: string;
+    format?: "raw" | "parsed";
+    level?: string | string[];
+  }): Promise<any> {
+    const { debug } = await import("../../actions/debug.js");
+    return await debug({
+      logs_since: options.since,
+      storeName: options.storeName,
+      format: options.format,
+      level: options.level,
+    });
+  }
+
+  /**
+   * Get all available log store names
+   */
+  async getLogStores(): Promise<string[]> {
+    const { debug } = await import("../../actions/debug.js");
+    const result = await debug({ getAllStores: true });
+    return result.availableStores || [];
+  }
 }
diff --git a/src/index.ts b/src/index.ts
index 975b46a..e103261 100644
--- a/src/index.ts
+++ b/src/index.ts
@@ -134,6 +134,7 @@ program
             sessionManager,
             configManager,
             mcpServer.getIris(), // Share the same IrisOrchestrator instance
+            mcpServer.getPendingPermissions(), // Enable permission approval UI
           );
           await webServer.start(config.dashboard);
         } catch (error) {
@@ -305,6 +306,7 @@ if (process.argv.length === 2) {
             sessionManager,
             configManager,
             mcpServer.getIris(), // Share the same IrisOrchestrator instance
+            mcpServer.getPendingPermissions(), // Enable permission approval UI
           );
           await webServer.start(config.dashboard);
         } catch (error) {
diff --git a/src/iris.ts b/src/iris.ts
index 151e669..2e5c0fb 100644
--- a/src/iris.ts
+++ b/src/iris.ts
@@ -22,6 +22,7 @@ import { getChildLogger } from "./utils/logger.js";
 import { filter, tap } from "rxjs/operators";
 import type { Subscription } from "rxjs";
 import type { TeamsConfig } from "./process-pool/types.js";
+import type { PendingPermissionsManager } from "./permissions/pending-manager.js";
 
 const logger = getChildLogger("iris:core");
 
@@ -61,13 +62,16 @@ export class IrisOrchestrator {
   private cacheManager: CacheManager;
   private responseTimeouts = new Map<string, NodeJS.Timeout>();
   private responseSubscriptions = new Map<string, Subscription>();
+  private pendingPermissions?: PendingPermissionsManager;
 
   constructor(
     private sessionManager: SessionManager,
     private processPool: ClaudeProcessPool,
     private config: TeamsConfig,
+    pendingPermissions?: PendingPermissionsManager,
   ) {
     this.cacheManager = new CacheManager();
+    this.pendingPermissions = pendingPermissions;
   }
 
   /**
@@ -150,6 +154,37 @@ export class IrisOrchestrator {
       fromTeam,
     );
 
+    // Step 4.5: Update session with debug info (if available from transport)
+    const launchCommand = process.getLaunchCommand?.();
+    const teamConfigSnapshot = process.getTeamConfigSnapshot?.();
+
+    logger.debug("Checking debug info from process", {
+      sessionId: session.sessionId,
+      hasGetLaunchCommand: typeof process.getLaunchCommand === 'function',
+      hasGetTeamConfigSnapshot: typeof process.getTeamConfigSnapshot === 'function',
+      launchCommandValue: launchCommand ? `${launchCommand.length} chars` : 'NULL',
+      teamConfigValue: teamConfigSnapshot ? `${teamConfigSnapshot.length} chars` : 'NULL',
+    });
+
+    if (launchCommand && teamConfigSnapshot) {
+      this.sessionManager.updateDebugInfo(
+        session.sessionId,
+        launchCommand,
+        teamConfigSnapshot,
+      );
+      logger.info("Updated session debug info", {
+        sessionId: session.sessionId,
+        commandLength: launchCommand.length,
+        configLength: teamConfigSnapshot.length,
+      });
+    } else {
+      logger.warn("Debug info not available from transport", {
+        sessionId: session.sessionId,
+        hasLaunchCommand: !!launchCommand,
+        hasTeamConfig: !!teamConfigSnapshot,
+      });
+    }
+
     // Step 5: Create CacheEntry for this tell
     const tellEntry = messageCache.createEntry(CacheEntryType.TELL, message);
 
@@ -649,8 +684,8 @@ export class IrisOrchestrator {
       };
     }
 
-    // Get permission mode (default: "yes")
-    const mode = teamConfig.grantPermission || "yes";
+    // Get permission mode (default: "ask")
+    const mode = teamConfig.grantPermission || "ask";
 
     logger.info({
       teamName,
@@ -680,15 +715,55 @@ export class IrisOrchestrator {
         };
 
       case "ask":
-        // TODO: Emit event to dashboard for manual approval
-        // For now, deny with message explaining feature not yet implemented
-        logger.warn({ teamName, toolName }, "Ask mode not yet implemented, denying");
-        return {
-          allow: false,
-          message: `Permission denied: Interactive approval (grantPermission: ask) not yet implemented for team '${teamName}'`,
-          teamName,
-          mode,
-        };
+        // Broadcast to dashboard for manual approval
+        if (!this.pendingPermissions) {
+          logger.warn({ teamName, toolName }, "Ask mode not available - no permissions manager");
+          return {
+            allow: false,
+            message: `Permission denied: Dashboard not available for approval`,
+            teamName,
+            mode,
+          };
+        }
+
+        logger.info({ teamName, toolName }, "Creating pending permission request for dashboard approval");
+
+        try {
+          // Create pending permission - this will be broadcasted to dashboard via events
+          const response = await this.pendingPermissions.createPendingPermission(
+            sessionId,
+            teamName,
+            toolName,
+            toolInput,
+            reason,
+          );
+
+          logger.info({
+            teamName,
+            toolName,
+            approved: response.approved,
+          }, "Permission request resolved by dashboard");
+
+          return {
+            allow: response.approved,
+            message: response.reason || (response.approved ? undefined : "Permission denied by user"),
+            teamName,
+            mode,
+          };
+        } catch (error) {
+          logger.error({
+            err: error instanceof Error ? error : new Error(String(error)),
+            teamName,
+            toolName,
+          }, "Error creating pending permission");
+
+          return {
+            allow: false,
+            message: `Permission denied: Error requesting approval - ${error instanceof Error ? error.message : String(error)}`,
+            teamName,
+            mode,
+          };
+        }
 
       case "forward":
         // TODO: Forward permission request to parent team
diff --git a/src/mcp_server.ts b/src/mcp_server.ts
index c5cd34e..90c7969 100644
--- a/src/mcp_server.ts
+++ b/src/mcp_server.ts
@@ -19,6 +19,7 @@ import { PoolEvent } from "./process-pool/types.js";
 import { SessionManager } from "./session/session-manager.js";
 import { IrisOrchestrator } from "./iris.js";
 import { getChildLogger } from "./utils/logger.js";
+import { PendingPermissionsManager } from "./permissions/pending-manager.js";
 import { getIrisHome, getConfigPath, getDataDir } from "./utils/paths.js";
 import { tell } from "./actions/tell.js";
 import { quickTell } from "./actions/quick_tell.js";
@@ -434,6 +435,7 @@ export class IrisMcpServer {
   private sessionManager: SessionManager;
   private processPool: ClaudeProcessPool;
   private iris: IrisOrchestrator;
+  private pendingPermissions: PendingPermissionsManager;
 
   constructor(
     sessionManager: SessionManager,
@@ -457,11 +459,17 @@ export class IrisMcpServer {
     this.processPool = processPool;
     this.configManager = configManager;
 
+    // Initialize pending permissions manager
+    const permissionTimeout =
+      this.configManager.getConfig().settings?.permissionTimeout || 30000;
+    this.pendingPermissions = new PendingPermissionsManager(permissionTimeout);
+
     // Initialize Iris orchestrator (BLL)
     this.iris = new IrisOrchestrator(
       this.sessionManager,
       this.processPool,
       this.configManager.getConfig(),
+      this.pendingPermissions,
     );
 
     // Set up MCP handlers
@@ -823,6 +831,14 @@ export class IrisMcpServer {
     });
   }
 
+  /**
+   * Get the PendingPermissionsManager instance
+   * Used by dashboard bridge to access pending permissions
+   */
+  getPendingPermissions(): PendingPermissionsManager {
+    return this.pendingPermissions;
+  }
+
   async run(
     transport: "stdio" | "http" = "stdio",
     port: number = 1615,
diff --git a/src/permissions/pending-manager.ts b/src/permissions/pending-manager.ts
new file mode 100644
index 0000000..f7c1cbf
--- /dev/null
+++ b/src/permissions/pending-manager.ts
@@ -0,0 +1,251 @@
+/**
+ * PendingPermissionsManager - Tracks pending permission approval requests
+ *
+ * Manages permission requests waiting for dashboard approval with timeout handling.
+ * Each pending request is tracked by a unique ID and resolves via Promise when
+ * dashboard responds or timeout occurs.
+ */
+
+import { EventEmitter } from "events";
+import { getChildLogger } from "../utils/logger.js";
+
+const logger = getChildLogger("permissions:pending");
+
+export interface PendingPermissionRequest {
+  permissionId: string;
+  sessionId: string;
+  teamName: string;
+  toolName: string;
+  toolInput: Record<string, unknown>;
+  reason?: string;
+  createdAt: Date;
+}
+
+export interface PendingPermissionResponse {
+  approved: boolean;
+  reason?: string;
+}
+
+interface PendingEntry {
+  request: PendingPermissionRequest;
+  resolve: (response: PendingPermissionResponse) => void;
+  reject: (error: Error) => void;
+  timeoutTimer: NodeJS.Timeout;
+}
+
+/**
+ * Manages pending permission requests with timeout and Promise-based resolution
+ */
+export class PendingPermissionsManager extends EventEmitter {
+  private pending = new Map<string, PendingEntry>();
+  private permissionCounter = 0;
+  private defaultTimeout: number;
+
+  constructor(defaultTimeoutMs = 30000) {
+    super();
+    this.defaultTimeout = defaultTimeoutMs;
+  }
+
+  /**
+   * Generate unique permission ID
+   */
+  private generatePermissionId(): string {
+    return `perm_${Date.now()}_${++this.permissionCounter}`;
+  }
+
+  /**
+   * Create new pending permission request
+   * Returns a Promise that resolves when dashboard responds or timeout occurs
+   */
+  async createPendingPermission(
+    sessionId: string,
+    teamName: string,
+    toolName: string,
+    toolInput: Record<string, unknown>,
+    reason?: string,
+    timeoutMs?: number,
+  ): Promise<PendingPermissionResponse> {
+    const permissionId = this.generatePermissionId();
+    const timeout = timeoutMs ?? this.defaultTimeout;
+
+    const request: PendingPermissionRequest = {
+      permissionId,
+      sessionId,
+      teamName,
+      toolName,
+      toolInput,
+      reason,
+      createdAt: new Date(),
+    };
+
+    logger.info(
+      {
+        permissionId,
+        sessionId,
+        teamName,
+        toolName,
+        timeout,
+      },
+      "Creating pending permission request",
+    );
+
+    // Create Promise that will be resolved by dashboard response or timeout
+    const promise = new Promise<PendingPermissionResponse>((resolve, reject) => {
+      // Set timeout timer
+      const timeoutTimer = setTimeout(() => {
+        this.handleTimeout(permissionId);
+      }, timeout);
+
+      // Store entry
+      this.pending.set(permissionId, {
+        request,
+        resolve,
+        reject,
+        timeoutTimer,
+      });
+    });
+
+    // Emit event for WebSocket broadcast
+    this.emit("permission:created", request);
+
+    return promise;
+  }
+
+  /**
+   * Resolve pending permission with dashboard response
+   */
+  resolvePendingPermission(
+    permissionId: string,
+    approved: boolean,
+    reason?: string,
+  ): boolean {
+    const entry = this.pending.get(permissionId);
+    if (!entry) {
+      logger.warn({ permissionId }, "Permission not found for resolution");
+      return false;
+    }
+
+    logger.info(
+      {
+        permissionId,
+        approved,
+        teamName: entry.request.teamName,
+      },
+      "Resolving pending permission",
+    );
+
+    // Clear timeout
+    clearTimeout(entry.timeoutTimer);
+
+    // Resolve promise
+    entry.resolve({ approved, reason });
+
+    // Remove from pending
+    this.pending.delete(permissionId);
+
+    // Emit event
+    this.emit("permission:resolved", {
+      permissionId,
+      approved,
+      reason,
+    });
+
+    return true;
+  }
+
+  /**
+   * Handle permission timeout
+   */
+  private handleTimeout(permissionId: string): void {
+    const entry = this.pending.get(permissionId);
+    if (!entry) {
+      return;
+    }
+
+    logger.warn(
+      {
+        permissionId,
+        teamName: entry.request.teamName,
+        toolName: entry.request.toolName,
+      },
+      "Permission request timed out",
+    );
+
+    // Resolve with denial
+    entry.resolve({
+      approved: false,
+      reason: "Permission request timed out - no dashboard response received",
+    });
+
+    // Remove from pending
+    this.pending.delete(permissionId);
+
+    // Emit event
+    this.emit("permission:timeout", {
+      permissionId,
+      request: entry.request,
+    });
+  }
+
+  /**
+   * Get all pending permission requests
+   */
+  getPendingRequests(): PendingPermissionRequest[] {
+    return Array.from(this.pending.values()).map((entry) => entry.request);
+  }
+
+  /**
+   * Get specific pending request by ID
+   */
+  getPendingRequest(permissionId: string): PendingPermissionRequest | undefined {
+    return this.pending.get(permissionId)?.request;
+  }
+
+  /**
+   * Cancel specific pending request
+   */
+  cancelPendingPermission(permissionId: string): boolean {
+    const entry = this.pending.get(permissionId);
+    if (!entry) {
+      return false;
+    }
+
+    logger.info({ permissionId }, "Canceling pending permission");
+
+    clearTimeout(entry.timeoutTimer);
+    entry.resolve({
+      approved: false,
+      reason: "Permission request canceled",
+    });
+
+    this.pending.delete(permissionId);
+    return true;
+  }
+
+  /**
+   * Clear all pending permissions (e.g., on shutdown)
+   */
+  clearAll(): void {
+    logger.info(
+      { count: this.pending.size },
+      "Clearing all pending permissions",
+    );
+
+    for (const [permissionId, entry] of this.pending.entries()) {
+      clearTimeout(entry.timeoutTimer);
+      entry.resolve({
+        approved: false,
+        reason: "Server shutting down",
+      });
+    }
+
+    this.pending.clear();
+  }
+
+  /**
+   * Get count of pending permissions
+   */
+  get pendingCount(): number {
+    return this.pending.size;
+  }
+}
diff --git a/src/session/session-manager.ts b/src/session/session-manager.ts
index 4e999d3..c26a580 100644
--- a/src/session/session-manager.ts
+++ b/src/session/session-manager.ts
@@ -325,6 +325,31 @@ export class SessionManager {
     }
   }
 
+  /**
+   * Update launch command and team config snapshot for a session
+   * Called by Transport layer after process is spawned
+   */
+  updateDebugInfo(
+    sessionId: string,
+    launchCommand: string,
+    teamConfigSnapshot: string,
+  ): void {
+    this.ensureInitialized();
+    this.store.updateDebugInfo(sessionId, launchCommand, teamConfigSnapshot);
+
+    // Invalidate cache for this session
+    const session = this.store.getBySessionId(sessionId);
+    if (session) {
+      this.invalidateCache(session.fromTeam, session.toTeam);
+    }
+
+    logger.debug("Updated session debug info", {
+      sessionId,
+      commandLength: launchCommand.length,
+      configLength: teamConfigSnapshot.length,
+    });
+  }
+
   /**
    * Increment message count for session
    */
diff --git a/src/session/session-store.ts b/src/session/session-store.ts
index 3f8ded2..d2cc1bd 100644
--- a/src/session/session-store.ts
+++ b/src/session/session-store.ts
@@ -105,6 +105,8 @@ export class SessionStore {
         process_state TEXT NOT NULL DEFAULT 'stopped',
         current_cache_session_id TEXT,
         last_response_at INTEGER,
+        launch_command TEXT,
+        team_config_snapshot TEXT,
         UNIQUE(from_team, to_team)
       );
 
@@ -137,23 +139,39 @@ export class SessionStore {
       processState: row.process_state,
       currentCacheSessionId: row.current_cache_session_id ?? null,
       lastResponseAt: row.last_response_at ?? null,
+      launchCommand: row.launch_command ?? null,
+      teamConfigSnapshot: row.team_config_snapshot ?? null,
     };
   }
 
   /**
    * Create a new session record
    */
-  create(fromTeam: string, toTeam: string, sessionId: string): SessionInfo {
+  create(
+    fromTeam: string,
+    toTeam: string,
+    sessionId: string,
+    launchCommand?: string,
+    teamConfigSnapshot?: string,
+  ): SessionInfo {
     const now = Date.now();
 
     const stmt = this.db.prepare(`
       INSERT INTO team_sessions (
         from_team, to_team, session_id, created_at, last_used_at, message_count, status,
-        process_state, current_cache_session_id, last_response_at
-      ) VALUES (?, ?, ?, ?, ?, 0, 'active', 'stopped', NULL, NULL)
+        process_state, current_cache_session_id, last_response_at, launch_command, team_config_snapshot
+      ) VALUES (?, ?, ?, ?, ?, 0, 'active', 'stopped', NULL, NULL, ?, ?)
     `);
 
-    const result = stmt.run(fromTeam, toTeam, sessionId, now, now);
+    const result = stmt.run(
+      fromTeam,
+      toTeam,
+      sessionId,
+      now,
+      now,
+      launchCommand ?? null,
+      teamConfigSnapshot ?? null,
+    );
 
     logger.info("Session created", {
       fromTeam,
@@ -174,6 +192,8 @@ export class SessionStore {
       process_state: "stopped",
       current_cache_session_id: null,
       last_response_at: null,
+      launch_command: launchCommand ?? null,
+      team_config_snapshot: teamConfigSnapshot ?? null,
     });
   }
 
@@ -481,6 +501,25 @@ export class SessionStore {
     logger.debug("Updated last response timestamp", { sessionId, timestamp });
   }
 
+  /**
+   * Update launch command and team config snapshot for debugging
+   */
+  updateDebugInfo(
+    sessionId: string,
+    launchCommand: string,
+    teamConfigSnapshot: string,
+  ): void {
+    const stmt = this.db.prepare(`
+      UPDATE team_sessions
+      SET launch_command = ?, team_config_snapshot = ?
+      WHERE session_id = ?
+    `);
+
+    stmt.run(launchCommand, teamConfigSnapshot, sessionId);
+
+    logger.debug("Updated debug info", { sessionId });
+  }
+
   /**
    * Reset all process states to 'stopped' on server startup
    * This clears stale runtime state from previous server instances
diff --git a/src/session/types.ts b/src/session/types.ts
index 1bdd8b5..24a9f27 100644
--- a/src/session/types.ts
+++ b/src/session/types.ts
@@ -63,6 +63,12 @@ export interface SessionInfo {
 
   /** Timestamp of last response from Claude */
   lastResponseAt: number | null;
+
+  /** Full command used to spawn this session (for debugging) */
+  launchCommand: string | null;
+
+  /** Snapshot of server-side team config at session creation (for debugging) */
+  teamConfigSnapshot: string | null; // JSON string of relevant config values
 }
 
 /**
@@ -80,6 +86,8 @@ export interface SessionRow {
   process_state: ProcessState;
   current_cache_session_id: string | null;
   last_response_at: number | null;
+  launch_command: string | null;
+  team_config_snapshot: string | null;
 }
 
 /**
diff --git a/src/web_server.ts b/src/web_server.ts
index d4a01b9..43446b6 100644
--- a/src/web_server.ts
+++ b/src/web_server.ts
@@ -8,6 +8,7 @@ import type { ClaudeProcessPool } from "./process-pool/pool-manager.js";
 import type { SessionManager } from "./session/session-manager.js";
 import type { TeamsConfigManager } from "./config/iris-config.js";
 import type { IrisOrchestrator } from "./iris.js";
+import type { PendingPermissionsManager } from "./permissions/pending-manager.js";
 import type { DashboardConfig } from "./process-pool/types.js";
 import { DashboardStateBridge } from "./dashboard/server/state-bridge.js";
 import { startDashboardServer } from "./dashboard/server/index.js";
@@ -23,14 +24,17 @@ export class IrisWebServer {
     private sessionManager: SessionManager,
     private configManager: TeamsConfigManager,
     iris?: IrisOrchestrator,
+    pendingPermissions?: PendingPermissionsManager,
   ) {
     // Create the bridge between MCP components and dashboard
     // Pass iris instance to share the same CacheManager
+    // Pass pendingPermissions to enable permission approval UI
     this.bridge = new DashboardStateBridge(
       this.processPool,
       this.sessionManager,
       this.configManager,
       iris,
+      pendingPermissions,
     );
 
     logger.info("Iris Web Server initialized");

--- Agent Processing ---
Unit Test Agent: pending
Tech Writer Agent: pending
Examples Guru Agent: pending

===== End Session [2025-10-17 16:43:26] =====


