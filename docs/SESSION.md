# Session Management Architecture

## Overview

Iris MCP implements **persistent team-to-team sessions** to maintain conversation continuity across all inter-team communications. Each unique pair of communicating teams shares a dedicated Claude Code session that persists across process restarts and pooling operations.

## The Problem

Without session management, every Claude process spawn creates a new conversation context, causing:

- **Context fragmentation**: Each interaction starts with no memory of previous exchanges
- **Directory pollution**: Projects accumulate dozens of orphaned session files
- **Lost continuity**: Teams cannot reference prior conversations
- **Defeats pooling benefits**: Process reuse doesn't preserve conversation state

## Solution: Team-to-Team Session Matrix

### Core Design Principle

**Each unique `(fromTeam, toTeam)` pair has exactly one persistent session.**

This means:
- `frontend → backend` has its own session
- `backend → frontend` has a **different** session
- `mobile → backend` has yet another session
- Sessions are **directional** and **isolated**

### Why Team-to-Team Instead of Per-Team?

Different requesters need different context when talking to the same team:

```
frontend asking backend about API design  ≠  mobile asking backend about GraphQL schema
```

Team-to-team isolation prevents context pollution while maintaining relevant conversation threads.

## Implementation Architecture

### 1. Session Storage (SQLite)

**Database**: `data/team-sessions.db`

**Schema**:
```sql
CREATE TABLE team_sessions (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  from_team TEXT NOT NULL,
  to_team TEXT NOT NULL,
  session_id TEXT NOT NULL UNIQUE,  -- UUID v4
  created_at INTEGER NOT NULL,       -- Unix timestamp (ms)
  last_used_at INTEGER NOT NULL,     -- Unix timestamp (ms)
  message_count INTEGER DEFAULT 0,
  status TEXT DEFAULT 'active',      -- active, compact_pending, archived
  UNIQUE(from_team, to_team)
);

CREATE INDEX idx_team_sessions_from_to ON team_sessions(from_team, to_team);
CREATE INDEX idx_team_sessions_session_id ON team_sessions(session_id);
CREATE INDEX idx_team_sessions_status ON team_sessions(status);
```

**Notes**:
- `from_team` can be NULL for external/user-initiated requests
- `session_id` is a UUID v4 generated by Iris
- SQLite in WAL mode for concurrent access
- Metadata tracks usage for future optimization

### 2. Session Lifecycle

#### Phase 1: Startup Discovery

On MCP server startup, `SessionManager` performs:

1. **Load existing sessions** from `data/team-sessions.db`
2. **Scan Claude directories** for each configured team:
   - Read `project` property from `teams.json` (**case-sensitive**)
   - Compute escaped path: `/Users/jenova/projects/foo` → `-Users-jenova-projects-foo`
   - Check `~/.claude/projects/{escaped-path}/` for existing session files
3. **Sync database with filesystem**:
   - Add discovered sessions to database if missing
   - Mark database entries as invalid if session files don't exist
   - Pre-create sessions for common team pairs (optional optimization)

**IMPORTANT**: The `project` property in `teams.json` is **case-sensitive** and must match the actual filesystem path exactly.

#### Phase 2: Session Initialization (CRITICAL)

**Sessions MUST be pre-created before they can be resumed.** This is a two-step process:

##### Step 1: Create Session File

When a new `(fromTeam, toTeam)` pair is encountered:

1. **Generate UUID v4** for the session
2. **Create the session** by spawning Claude with `--session-id`:
   ```bash
   cd {toTeam.project}
   claude --session-id {uuid} --print --input-format stream-json --output-format stream-json
   ```
   **Critical**: `--session-id <uuid>` creates a NEW session but will NOT resume an existing one

3. **Send initialization ping** immediately after spawn to create conversation:
   ```json
   {"type":"user","message":{"role":"user","content":[{"type":"text","text":"Session initialized"}]}}
   ```

4. **Wait for response** from Claude (init message + response to ping)

5. **Exit the process** cleanly

6. **Verify session file created** in `~/.claude/projects/{escaped-path}/{uuid}.jsonl`

7. **Store in database** with metadata (created_at, last_used_at)

##### Step 2: At Startup - Validate All Sessions

During `SessionManager.initialize()` (BEFORE any processes spawn):

1. **Load all teams** from `teams.json`
2. **For each team**:
   - Check if session exists in database for this team
   - If exists: Verify session file exists in `~/.claude/projects/{escaped-path}/{sessionId}.jsonl`
   - If file missing: Re-initialize session using Step 1
   - If no session in database: Generate new UUID and initialize using Step 1
3. **Wait for all sessions to be ready** before allowing MCP tools or tests to proceed

**Why this is critical:**
- `claude --resume` will FAIL if session doesn't exist
- Session file is only created when first conversation message is sent
- Tests and MCP startup MUST wait for all sessions to be initialized
- This prevents the "exit code 1" crash we were seeing

#### Phase 3: Session Usage

When processing MCP requests:

1. **Lookup session ID** for `(fromTeam, toTeam)` from database
2. **Spawn process with resume**:
   ```bash
   cd {toTeam.project}
   claude --resume {uuid} --print --output-format stream-json --input-format stream-json
   ```
   **Critical**: `--resume <uuid>` resumes EXISTING session but will NOT create a new one
3. **Update metadata** after successful message exchange:
   - Increment `message_count`
   - Update `last_used_at` timestamp

#### Phase 4: Session Maintenance (Future - Phase 2)

Periodic background tasks:

1. **Compact large sessions**:
   - Detect sessions with high message count (e.g., >1000 messages)
   - Execute `/compact` command to summarize and reduce context size
   - Update `status` to indicate compaction occurred

2. **Archive inactive sessions**:
   - Identify sessions unused for extended period (e.g., 90 days)
   - Mark as `archived` in database
   - Optionally delete session files to reclaim space

### 3. Path Escaping Algorithm

Claude Code escapes project paths for directory names using this pattern:

**Algorithm**:
```typescript
function escapeProjectPath(absolutePath: string): string {
  // Remove leading slash, replace remaining slashes with hyphens
  return '-' + absolutePath.slice(1).replace(/\//g, '-');
}
```

**Examples**:
| Absolute Path | Escaped Directory Name |
|--------------|------------------------|
| `/Users/jenova/projects/jenova-marie/iris-mcp` | `-Users-jenova-projects-jenova-marie-iris-mcp` |
| `/Users/jenova/projects/foo` | `-Users-jenova-projects-foo` |
| `/tmp/test` | `-tmp-test` |

**Important**: This escaping is case-sensitive and must match exactly.

### 4. MCP Tools API Changes

All communication tools now accept `fromTeam` parameter:

#### teams_ask

```typescript
{
  team: string,           // Destination team (REQUIRED)
  question: string,       // Question to ask (REQUIRED)
  fromTeam?: string,      // Requesting team (OPTIONAL, defaults to null for external)
  timeout?: number        // Timeout in ms (OPTIONAL, default 30000)
}
```

#### teams_send_message

```typescript
{
  toTeam: string,         // Destination team (REQUIRED)
  message: string,        // Message content (REQUIRED)
  fromTeam?: string,      // Requesting team (OPTIONAL, defaults to null)
  waitForResponse?: boolean,  // Wait for response (OPTIONAL, default true)
  timeout?: number        // Timeout in ms (OPTIONAL, default 30000)
}
```

#### teams_notify

```typescript
{
  toTeam: string,         // Destination team (REQUIRED)
  message: string,        // Notification content (REQUIRED)
  fromTeam?: string,      // Requesting team (OPTIONAL, defaults to null)
  ttlDays?: number        // TTL in days (OPTIONAL, default 30)
}
```

**Note**: `fromTeam` is optional because external callers (like user-initiated MCP requests) may not have a team identity. These use `fromTeam = null` and create sessions like `(null, "backend")`.

### 5. Configuration Schema Changes

The `teams.json` schema now requires a `project` property:

```json
{
  "settings": {
    "idleTimeout": 300000,
    "maxProcesses": 10,
    "healthCheckInterval": 30000
  },
  "teams": {
    "frontend": {
      "project": "/Users/jenova/projects/myapp/frontend",  // REQUIRED - case-sensitive
      "path": "/Users/jenova/projects/myapp/frontend",      // DEPRECATED but kept for compatibility
      "description": "Frontend team",
      "skipPermissions": true,
      "color": "#E91E63"
    }
  }
}
```

**Properties**:
- `project`: **REQUIRED** - Full absolute path to project directory (case-sensitive)
- `path`: **DEPRECATED** - Kept for backward compatibility, use `project` instead
- `description`: Human-readable team description
- `skipPermissions`: If true, use `--dangerously-skip-permissions` flag
- `color`: Hex color for future UI (Phase 2+)

**Validation**:
- `project` must be absolute path
- `project` must exist on filesystem
- `project` must be readable

## Session Manager Component

### Responsibilities

1. **Database Management**:
   - Initialize SQLite database with schema
   - CRUD operations for session records
   - Query sessions by team pairs

2. **Session Initialization** (CRITICAL - Runs at startup):
   - For each team in `teams.json`, ensure a session exists
   - Verify session file exists in `~/.claude/projects/{escaped-path}/{uuid}.jsonl`
   - If missing: Create session using `claude --session-id {uuid}` + ping
   - MUST complete BEFORE any ClaudeProcess can spawn with `--resume`
   - Returns Promise that resolves when all sessions are ready

3. **Session Discovery**:
   - Scan `~/.claude/projects/` for existing sessions
   - Match session files to configured teams
   - Sync database with filesystem state
   - Recover orphaned sessions (files without database entries)

4. **Session Creation**:
   - Generate UUIDs for new team pairs
   - Execute `claude --session-id <uuid>` to create sessions
   - Send initialization ping to create conversation
   - Wait for response and exit cleanly
   - Validate session file creation

5. **Session Retrieval**:
   - Lookup session ID for `(fromTeam, toTeam)` pairs
   - Create session on-demand if missing (async operation)
   - Return session metadata

6. **Metadata Tracking**:
   - Update `last_used_at` on each use
   - Increment `message_count` after messages
   - Track session health/status

### Interface

```typescript
interface SessionManager {
  // Initialization - MUST complete before any process spawns
  initialize(): Promise<void>;

  // Ensures session exists for team (creates if missing)
  ensureTeamSession(teamName: string): Promise<SessionInfo>;

  // Session lifecycle
  getOrCreateSession(fromTeam: string | null, toTeam: string): Promise<SessionInfo>;
  createSession(fromTeam: string | null, toTeam: string): Promise<SessionInfo>;

  // Internal: Initialize a new session file using claude --session-id
  initializeSessionFile(teamName: string, sessionId: string): Promise<void>;

  // Session queries
  getSession(fromTeam: string | null, toTeam: string): Promise<SessionInfo | null>;
  listSessions(filters?: SessionFilters): Promise<SessionInfo[]>;

  // Metadata updates
  recordUsage(sessionId: string): Promise<void>;
  incrementMessageCount(sessionId: string, count: number): Promise<void>;

  // Maintenance (Phase 2)
  compactSession(sessionId: string): Promise<void>;
  archiveSession(sessionId: string): Promise<void>;
}

interface SessionInfo {
  id: number;
  fromTeam: string | null;
  toTeam: string;
  sessionId: string;  // UUID
  createdAt: Date;
  lastUsedAt: Date;
  messageCount: number;
  status: 'active' | 'compact_pending' | 'archived';
}
```

## Process Pool Integration

### Modified ClaudeProcess

**Constructor**:
```typescript
constructor(
  teamName: string,
  teamConfig: TeamConfig,
  sessionId: string,  // NEW: Session UUID to resume
)
```

**Spawn command**:
```bash
cd {teamConfig.project}
claude --resume {sessionId} \
  --print \
  --verbose \
  --output-format stream-json \
  --input-format stream-json \
  ${teamConfig.skipPermissions ? '--dangerously-skip-permissions' : ''}
```

**Key changes**:
- Use `--resume` instead of letting Claude auto-create sessions
- Session ID passed from SessionManager via pool

### Modified ClaudeProcessPool

**Method signature change**:
```typescript
async getOrCreateProcess(
  teamName: string,
  fromTeam: string | null  // NEW: Requesting team for session lookup
): Promise<ClaudeProcess>
```

**Logic**:
1. Lookup session ID from SessionManager for `(fromTeam, teamName)`
2. Check if process exists in pool for `teamName`
3. If exists and healthy, return it
4. If not, spawn new process with `sessionId`
5. Track session usage metadata

## File Structure

```
src/
├── session/
│   ├── session-manager.ts       # SessionManager implementation
│   ├── session-store.ts         # SQLite database wrapper
│   ├── path-utils.ts            # Path escaping utilities
│   └── types.ts                 # Session-related types
├── process-pool/
│   ├── claude-process.ts        # Modified: accept sessionId
│   ├── pool-manager.ts          # Modified: integrate SessionManager
│   └── types.ts
├── tools/
│   ├── teams-ask.ts             # Modified: accept fromTeam
│   ├── teams-send-message.ts    # Modified: accept fromTeam
│   └── teams-notify.ts          # Already has fromTeam
└── config/
    └── teams-config.ts          # Validate 'project' property

data/
└── team-sessions.db             # SQLite database
```

## Error Handling

### Session Creation Failures

**Scenario**: `claude --session-id <uuid>` fails

**Handling**:
1. Log error with context (team, UUID, error message)
2. Retry once with new UUID (original may conflict)
3. If retry fails, throw `SessionCreationError`
4. Caller should handle gracefully (e.g., fallback to temporary session)

### Session Resume Failures

**Scenario**: `claude --resume <uuid>` fails (session file missing/corrupt)

**Handling**:
1. Log warning about missing session
2. Delete stale database entry
3. Create new session with fresh UUID
4. Continue with new session

### Database Corruption

**Scenario**: `team-sessions.db` is corrupt or locked

**Handling**:
1. Attempt database repair (SQLite PRAGMA integrity_check)
2. If repair fails, backup corrupt DB and create fresh database
3. Rediscover sessions from filesystem
4. Log incident for monitoring

## Security Considerations

1. **Path Traversal Prevention**:
   - Validate `project` paths are absolute and within allowed directories
   - Verify escaped paths don't contain `..` or other malicious patterns

2. **Session Hijacking**:
   - UUIDs are cryptographically random (UUID v4)
   - Session files stored in user's home directory (restricted permissions)
   - No API to retrieve arbitrary session IDs

3. **Input Validation**:
   - Team names validated against configuration (no arbitrary strings)
   - `fromTeam` must be known team or null
   - `toTeam` must exist in configuration

## Performance Optimization

### Pre-Creation Strategy (Phase 2)

On startup, pre-create sessions for **likely team pairs**:

1. Read historical usage from database
2. Identify top N most-used team pairs
3. Pre-create sessions in background
4. Reduces latency on first request

### Lazy vs Eager Creation

**Current (Phase 1)**: Lazy creation on first request
**Future (Phase 2)**: Eager pre-creation for predicted pairs

**Trade-off**:
- Lazy: Slower first request, but no wasted sessions
- Eager: Faster first request, but may create unused sessions

## Future Enhancements (Phase 2+)

### 1. Automatic Session Compaction

**Trigger**: Message count exceeds threshold (e.g., 1000 messages)

**Process**:
1. Send `/compact` command to running Claude process
2. Wait for compaction to complete
3. Update `status` in database to track compaction
4. Reset `message_count` or track pre/post-compact counts

### 2. Session Summarization

**Trigger**: Session approaching token limits

**Process**:
1. Extract conversation history from `.jsonl` file
2. Use Claude API to generate summary
3. Create new session with summary as initial context
4. Archive old session
5. Update database to point to new session

### 3. Multi-Session Threads

**Use case**: Team needs multiple parallel conversations

**Implementation**:
- Add `threadId` column to database
- Allow tools to specify `threadId` in parameters
- Store sessions as `(fromTeam, toTeam, threadId)` tuples

### 4. Session Analytics

**Metrics**:
- Average messages per session
- Session lifetime distribution
- Most active team pairs
- Token usage per session

**UI**: Dashboard showing session health and usage patterns (Phase 2+)

## Testing Strategy

### Unit Tests

- **Path escaping**: Verify algorithm matches Claude's behavior
- **Session CRUD**: Database operations work correctly
- **UUID generation**: Valid UUID v4 format

### Integration Tests

- **Session creation**: End-to-end `--session-id` flow
- **Session resume**: End-to-end `--resume` flow
- **Team-to-team isolation**: Verify sessions don't leak context
- **Database sync**: Filesystem discovery works correctly

### Manual Validation

- **Inspect session files**: Verify `.jsonl` content matches expected format
- **Multiple conversations**: Test different team pairs maintain isolation
- **Process restart**: Sessions persist across Iris restarts

## Migration Path

### Phase 1 (Current Implementation)

1. ✅ No session management - every spawn creates new context
2. ❌ Context pollution problem exists

### Phase 2 (This Design)

1. ✅ Implement SessionManager
2. ✅ Add `project` to team config
3. ✅ Modify tools to accept `fromTeam`
4. ✅ Create SQLite database
5. ✅ Integrate with process pool
6. ✅ Document and test

### Phase 3 (Enhancements)

1. Session compaction with `/compact`
2. Session summarization for long conversations
3. Analytics dashboard
4. Multi-session threads

## References

- **Claude CLI session flags**: `--session-id`, `--resume`, `--continue`, `--fork-session`
- **Session storage**: `~/.claude/projects/{escaped-path}/{uuid}.jsonl`
- **Session format**: NDJSON with linked messages (uuid, parentUuid)
- **UUID spec**: RFC 4122 (UUID v4)

## Appendix: Example Session Flow

### Scenario: Frontend asks Backend about API design

1. **User initiates** via frontend Claude instance:
   ```
   User: "Ask the backend team about their REST API design"
   ```

2. **Frontend Claude calls Iris MCP**:
   ```typescript
   teams_ask({
     team: "backend",
     question: "What's your REST API design for user endpoints?",
     fromTeam: "frontend",
     timeout: 30000
   })
   ```

3. **Iris SessionManager**:
   - Queries database for `(fromTeam: "frontend", toTeam: "backend")`
   - Finds session ID `a1b2c3d4-5678-90ab-cdef-1234567890ab`
   - Returns session info to pool

4. **Iris ProcessPool**:
   - Checks pool for existing `backend` process
   - If exists and idle, reuses it
   - If not, spawns:
     ```bash
     cd /Users/jenova/projects/backend
     claude --resume a1b2c3d4-5678-90ab-cdef-1234567890ab \
       --print --output-format stream-json --input-format stream-json
     ```

5. **Backend Claude**:
   - Loads conversation history from session file
   - Processes question with full context of previous frontend↔backend interactions
   - Sends response

6. **Iris records usage**:
   - Increments `message_count` for session
   - Updates `last_used_at` timestamp
   - Returns response to frontend

7. **Frontend Claude**:
   - Receives backend's response
   - Continues user conversation with backend's answer

**Result**: Next time frontend asks backend a question, Claude remembers this conversation about REST API design!
